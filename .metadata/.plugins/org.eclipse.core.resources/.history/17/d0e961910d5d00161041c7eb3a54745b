//opencv
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
#include "opencv2/opencv.hpp"
#include <opencv2/core/core.hpp>
//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>
using namespace cv;
using namespace std;
// Global variables
Mat backFrame, foreFrame; //current frame
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
int keyboard; //input from keyboard
int initcol = 0;

void help();
int createVideo(int nCamera, String fileName);
int createBackground();
int createFullBackground();
int createForeground();
void processVideo(const char* backFile, const char* foreFile);
void help()
{
    cout
    << "--------------------------------------------------------------------------" << endl
    << "This program shows how to use background subtraction methods provided by "  << endl
    << " OpenCV. You can process both videos (-vid) and images (-img)."             << endl
    << "--------------------------------------------------------------------------" << endl
    << endl;
}

int main()
{
    //print help information
	help();
	createVideo(1,"back2.avi");
	createVideo(1,"fore2.avi");

    //create Background Subtractor objects
    pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach

    processVideo("back2.avi","fore2.avi");

    //destroy GUI windows
    destroyAllWindows();
    return EXIT_SUCCESS;
}

int createVideo(int nCamera, String fileName)
{
	VideoCapture camera0(0); // Object to camera capturing by device zero..
	VideoCapture camera1, camera2;
	if(!camera0.isOpened()) return 1; // Check if camera is ready.
	if (nCamera==3){
		VideoCapture camera1(1);
		VideoCapture camera2(2);
    	if(!camera0.isOpened() && !camera0.isOpened()) return 1; // Check if camera is ready.
	}

    // Container to MJPEG codification as .avi video in 15 frames per second and 640 by 480 resolution.
    VideoWriter video(fileName, VideoWriter::fourcc('M','J','P','G'), 15, Size(nCamera*640,480), true);

    // Loop to build video
    int i=0;
    while(i<nCamera*45) {

        Mat frame0, frame1, frame2, merged_frame, roi; // Container for image.

        merged_frame = Mat(Size(nCamera*640, 480), CV_8UC3);
        camera0 >> frame0; // Put capture bytes inside the image container.
        roi = Mat(merged_frame, Rect(0, 0, 640, 480));
		frame0.copyTo(roi);
        if (nCamera==3){
        	camera1 >> frame1;
        	camera2 >> frame2;
    		roi = Mat(merged_frame, Rect(640, 0, 640, 480));
    		frame1.copyTo(roi);
    		roi = Mat(merged_frame, Rect(1280, 0, 640, 480));
    		frame2.copyTo(roi);
        }

        namedWindow( "Full background", WINDOW_AUTOSIZE );
		imshow("Full background", merged_frame); // Show current image of the video.
        video << merged_frame; // Put image inside video container.

        //Finish application by Esc key pressed.
        char ch =  waitKey(25);  // Wait for 25 ms for user to hit any key
		if(ch==27) break;  // If Escape Key was hit just exit the loop

		if(ch=='s' || ch=='S') // Save image if s was keyboard
		{
			imwrite("imgSaved.bmp", frame0);
		}
		i++;
    }
    destroyAllWindows();
    return 1;
}

void processVideo(const char* backFile, const char* foreFile) {
    //create the capture object
    VideoCapture foreCap(foreFile);
    VideoCapture backCap(backFile);
    VideoWriter video("final.avi", VideoWriter::fourcc('M','J','P','G'), 15, Size(640, 480), true);
    Mat background, character, bwFore, clFore, bwForeInv, bwFinal, bwFinalInv, roi; // Container for image.

    if(!foreCap.isOpened()){
        //error in opening the video input
        cerr << "Unable to open video file: " << foreFile << endl;
        exit(EXIT_FAILURE);
    }else if(!backCap.isOpened()){
        //error in opening the video input
        cerr << "Unable to open video file: " << backFile << endl;
        exit(EXIT_FAILURE);
    }

    //read input data. ESC or 'q' for quitting
    int count = 0;
    while( (char)keyboard != 'q' && (char)keyboard != 27 ){
    	cout << count << endl;

        //read the current frame
        if(!backCap.read(backFrame)) {
            cerr << "Unable to read next frame." << endl;
            cerr << "Exiting..." << endl;
            exit(EXIT_FAILURE);
        }
        if(!foreCap.read(foreFrame)) {
            initcol += 640;
            foreCap.set(CAP_PROP_POS_FRAMES, 0);
            foreCap.read(foreFrame);
        }

        roi = Mat(backFrame, Rect(initcol, 0, 640, 480));

        //update the background model
        pMOG2->apply(foreFrame, fgMaskMOG2);

        /*get the frame number and write it on the current frame
        stringstream ss;
        rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
                  cv::Scalar(255,255,255), -1);
        ss << foreCap.get(CAP_PROP_POS_FRAMES);
        string frameNumberString = ss.str();
        putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
                FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));*/
        
        cvtColor(fgMaskMOG2, bwFore, COLOR_GRAY2RGB);
        threshold(bwFore, bwFore, 10, 255, THRESH_BINARY);

        // create an image like frame but initialized to zeros
        Mat colorForeground = Mat::zeros(foreFrame.size(), foreFrame.type());
        // copy color objects into the new image using mask
        foreFrame.copyTo(colorForeground, fgMaskMOG2);

        bitwise_or(bwFore, roi, roi);
        foreFrame.copyTo(roi, colorForeground);

        namedWindow( "bw", WINDOW_AUTOSIZE );
        imshow("bw", backFrame); // Show current image of the video.

        //video << bwFinal;
        keyboard = waitKey( 30 );
        count++;
    }

    //delete capture object
    foreCap.release();
    backCap.release();
    video.release();
}
