//opencv
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
#include "opencv2/opencv.hpp"
#include <opencv2/core/core.hpp>
//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>
using namespace cv;
using namespace std;
// Global variables
Mat backframe, foreframe; //current frame
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
int keyboard; //input from keyboard
int initcol = 0;
void help();
int createBackground();
int createFullBackground();
int createForeground();
void processVideo(const char* backFile, const char* foreFile);
void help()
{
    cout
    << "--------------------------------------------------------------------------" << endl
    << "This program shows how to use background subtraction methods provided by "  << endl
    << " OpenCV. You can process both videos (-vid) and images (-img)."             << endl
    << "--------------------------------------------------------------------------" << endl
    << endl;
}

int main()
{
    //print help information
	help();
	//createBackground();
	//createFullBackground();
	//createCharacter();

    //create Background Subtractor objects
    pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach

    processVideo("back.avi","fore.avi");

    //destroy GUI windows
    destroyAllWindows();
    return EXIT_SUCCESS;
}

int createFullBackground()
{
    VideoCapture camera0(0); // Object to camera capturing by device zero..
    //VideoCapture camera1(1);
    //VideoCapture camera2(2);
    //if( !camera0.isOpened() && !camera0.isOpened() && !camera0.isOpened() ) return 1; // Check if camera is ready.

    if( !camera0.isOpened() ) return 1; // Check if camera is ready.

    // Container to MJPEG codification as .avi video in 15 frames per second and 640 by 480 resolution.
    VideoWriter video("back.avi", VideoWriter::fourcc('M','J','P','G'), 15, Size(1920, 480), true);

    // Loop to build video
    int i=0;
    while(i<135) {

        Mat frame0, frame1, frame2, merged_frame, roi; // Container for image.

        camera0 >> frame0; // Put capture bytes inside the image container.
        //camera1 >> frame1;
        //camera2 >> frame2;

        merged_frame = Mat(Size(1920, 480), CV_8UC3);
        roi = Mat(merged_frame, Rect(0, 0, 640, 480));
		frame0.copyTo(roi);
		roi = Mat(merged_frame, Rect(640, 0, 640, 480));
		//frame1.copyTo(roi);
		frame0.copyTo(roi);
		roi = Mat(merged_frame, Rect(1280, 0, 640, 480));
		//frame2.copyTo(roi);
		frame0.copyTo(roi);

        namedWindow( "Full background", WINDOW_AUTOSIZE );
		imshow("Full background", merged_frame); // Show current image of the video.
        video << merged_frame; // Put image inside video container.

        //Finish application by Esc key pressed.
        char ch =  waitKey(25);  // Wait for 25 ms for user to hit any key
		if(ch==27) break;  // If Escape Key was hit just exit the loop

		if(ch=='s' || ch=='S') // Save image if s was keyboard
		{
			imwrite("imgSaved.bmp", frame0);
		}
		i++;
    }
    destroyAllWindows();
    return 1;
}

int createBackground(){

	VideoCapture camera0(0); // Object to camera capturing by device zero.
	if( !camera0.isOpened() ) return 1; // Check if camera is ready.

	// Container to MJPEG codification as .avi video in 15 frames per second and 640 by 480 resolution.
	VideoWriter back("back.avi", VideoWriter::fourcc('M','J','P','G'), 15, Size(640, 480), true);
	Mat frame0; // Container for image.

	// Loop to build video
	int i=0;
	while(i<135) {

		camera0 >> frame0; // Put capture bytes inside the image container.
		imshow("im3", frame0); // Show current image of the video.
		back << frame0; // Put image inside video container.

		//Finish application by Esc key pressed.
		char ch =  waitKey(25);  // Wait for 25 ms for user to hit any key
		if(ch==27) break;  // If Escape Key was hit just exit the loop

		if(ch=='s' || ch=='S') // Save image if s was keyboard
		{
			imwrite("imgSaved.bmp", frame0);
		}
		i++;
	}
	destroyAllWindows();
	return 1;
}

int createForeground(){

	VideoCapture camera0(0); // Object to camera capturing by device zero.
	if( !camera0.isOpened() ) return 1; // Check if camera is ready.

	// Container to MJPEG codification as .avi video in 15 frames per second and 640 by 480 resolution.
	VideoWriter fore("fore.avi", VideoWriter::fourcc('M','J','P','G'), 15, Size(640, 480), true);
	Mat frame0; // Container for image.

	// Loop to build video
	int i=0;
	while(i<30) {

		camera0 >> frame0; // Put capture bytes inside the image container.
		imshow("im3", frame0); // Show current image of the video.
		fore << frame0; // Put image inside video container.

		//Finish application by Esc key pressed.
		char ch =  waitKey(25);  // Wait for 25 ms for user to hit any key
		if(ch==27) break;  // If Escape Key was hit just exit the loop

		if(ch=='s' || ch=='S') // Save image if s was keyboard
		{
			imwrite("imgSaved.bmp", frame0);
		}
		i++;
	}
	destroyAllWindows();
	return 1;
}

void processVideo(const char* backFile, const char* foreFile) {
    //create the capture object
    VideoCapture foreCap(foreFile);
    VideoCapture backCap(backFile);
    VideoWriter video("final.avi", VideoWriter::fourcc('M','J','P','G'), 15, Size(640, 480), true);
    Mat background, character, bwFore, clFore, bwForeInv, bwFinal, bwFinalInv, roi; // Container for image.

    if(!foreCap.isOpened()){
        //error in opening the video input
        cerr << "Unable to open video file: " << foreFile << endl;
        exit(EXIT_FAILURE);
    }else if(!backCap.isOpened()){
        //error in opening the video input
        cerr << "Unable to open video file: " << backFile << endl;
        exit(EXIT_FAILURE);
    }

    //read input data. ESC or 'q' for quitting
    int count = 0;
    while( (char)keyboard != 'q' && (char)keyboard != 27 ){
    	cout << count << endl;
    	backCap >> background; // Put capture bytes inside the image container.

    	roi = Mat(background, Rect(initcol, 0, 640, 480));

        //read the current frame
        if(!backCap.read(backframe)) {
            cerr << "Unable to read next frame." << endl;
            cerr << "Exiting..." << endl;
            exit(EXIT_FAILURE);
        }
        if(!foreCap.read(foreframe)) {

            initcol += 640;
            foreCap.set(CV_CAP_PROP_POS_AVI_RATIO, 0);
            cerr << "Acabou fore" << endl;
        }

        //update the background model
        pMOG2->apply(foreframe, fgMaskMOG2);

        /*get the frame number and write it on the current frame
        stringstream ss;
        rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
                  cv::Scalar(255,255,255), -1);
        ss << foreCap.get(CAP_PROP_POS_FRAMES);
        string frameNumberString = ss.str();
        putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
                FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));*/
        
        cvtColor(fgMaskMOG2, bwFore, COLOR_GRAY2RGB);
        threshold(bwFore, bwFore, 10, 255, THRESH_BINARY);

        // create an image like frame but initialized to zeros
        Mat colorForeground = Mat::zeros(foreframe.size(), foreframe.type());
        // copy color objects into the new image using mask
        foreframe.copyTo(colorForeground, fgMaskMOG2);


        bitwise_or(bwFore, roi, roi);
        foreframe.copyTo(roi, colorForeground);

        namedWindow( "bw", WINDOW_AUTOSIZE );
        imshow("bw", background); // Show current image of the video.

        //video << bwFinal;
        keyboard = waitKey( 30 );
        count++;
    }

    //delete capture object
    foreCap.release();
    backCap.release();
    video.release();
}
